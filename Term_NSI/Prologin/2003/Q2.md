# Correction de [Comparer des cha√Ænes](https://prologin.org/train/2003/qualification/comparer_des_chaines) {ignore}

Quelques propositions d'√©l√®ves, et √† la fin un corrig√© du professeur.

[TOC]

## Propositions d'√©l√®ves

√Ä la suite de chaque proposition de code, un commentaire de correction du professeur. Le cartouche demand√© en introduction a √©t√© supprim√© ici.

### Proposition 1

```python
def comparaison_alphab√©tique(nb_caract√®re1: int, cha√Æne1: str, nb_caract√®re2: int, cha√Æne2: str) -> str:
    """Cette fonction prend en param√®tre deux cha√Ænes de caract√®res compos√©es uniquement de lettre minuscules 
    et sans accents ainsi que le nombre de caract√®re, et renvoie la premi√®re selon l'odre lexicographique.
    >>> 8
        prologin
        5
        prolo
    prolo
    """
    nb_caract√®re_min = 0
    if nb_caract√®re1 < nb_caract√®re2:
        nb_caract√®re_min = nb_caract√®re1
    else:
        nb_caract√®re_min = nb_caract√®re2
    for x in range(nb_caract√®re_min):
        if x + 1 == nb_caract√®re_min:
            if cha√Æne1[x] < cha√Æne2[x]:
                return cha√Æne1 
            else:
                return cha√Æne2
        if cha√Æne1[x] == cha√Æne2[x]:
            pass
        else:
            if cha√Æne1[x] < cha√Æne2[x]:
                return cha√Æne1 
            else:
                return cha√Æne2
   
# tests 
import doctest
doctest.testmod()

# Entr√©e
nb_caract√®re1 = int(input())
cha√Æne1 = input()
nb_caract√®re2 = int(input())
cha√Æne2 = input()
# Sortie
print(comparaison_alphab√©tique(nb_caract√®re1, cha√Æne1, nb_caract√®re2, cha√Æne2))
```

* Ceci ne peut pas se produire !!!
```python
   for x in range(nb_caract√®re_min):
        if x + 1 == nb_caract√®re_min:
```

### Proposition 2

```python
import itertools 
def comparaison_lexicographique(cha√Æne1:str,cha√Æne2:str) -> str:
    """ Prend 2 cha√Ænes de caract√®res en minuscule et renvoie la plus petite selon l'ordre lexicographique
    >>> comparaison_lexicographique('bonjour','hola')
    'bonjour'
    >>> comparaison_lexicographique('holaster','hola')
    'hola'
    """
    alphabet = ['a', 'b', 'c', 'd', 'e','f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o','p', 'q', 'r', 's', 't', 'u', 'v','w','x', 'y', 'z']
    liste_cha√Æne1 = list(cha√Æne1)
    liste_cha√Æne2 = list(cha√Æne2)

    # On fait un tupple de chaque lettre de m√™me rang dans chaque cha√Æne et puis on l'ins√®re dans une liste,√ßa permet d'√©viter les probl√®mes de taille
    liste_comparaison = list(zip(liste_cha√Æne1,liste_cha√Æne2))

    # On compare chaque lettre en regardant leurs positionnement dans la liste alphabet et renvoie la cha√Æne la plus petite
    for lettre_cha√Æne1,lettre_cha√Æne2 in liste_comparaison:
        # On prend le positionnement dans l'alphabet de chaque lettre √† la m√™me position dans les 2 cha√Ænes de caract√®res
        positionnement_lettre_cha√Æne1 = alphabet.index(lettre_cha√Æne1)
        positionnement_lettre_cha√Æne2 = alphabet.index(lettre_cha√Æne2)

        # On cherche le plus petit selon l'odre l√©xicographique
        if positionnement_lettre_cha√Æne1 > positionnement_lettre_cha√Æne2:
            return cha√Æne2
        if positionnement_lettre_cha√Æne1 < positionnement_lettre_cha√Æne2:
            return cha√Æne1
    # Si il y a les m√™mes lettres sur le m√™me intervalle on renvoie la cha√Æne de caract√®re la plus courte
    if len(liste_cha√Æne1) > len(liste_cha√Æne2):
        return cha√Æne2
    else:
        return cha√Æne1


# tests
import doctest
doctest.testmod()

# Entr√©e
nb_caract√®res_cha√Æne1 = int(input())
cha√Æne1 = input()
nb_caract√®res_cha√Æne2 = int(input())
cha√Æne2 = input()

# Sortie
print(comparaison_lexicographique(cha√Æne1,cha√Æne2))
```

* C'est bien, il n'y a pas de triche.
* On peut faire bien plus simple. Voir corrig√©.

### Proposition 3

```python
longueur_mot1 = int(input())
mot1 = input()
longueur_mot2 = int(input())
mot2 = input()

liste = [mot1, mot2]

liste.sort()

print liste[0]
```


1. L'auteur de ce code fait du Python2 √† la fin, pas du Python3 ; ce n'est probablement pas un √©l√®ve en NSI.
2. L'esprit du probl√®me est de ne pas utiliser les outils *builtin* comme `<` (sur les cha√Ænes) ou `.sort()`...
3. On attend une fonction avec *doctest*.
4. `mot_1` est plus clair que `mot1`.

### Proposition 4

```python
longueur_premier_mot = int(input())
premier_mot = input()
longueur_second_mot = int(input())
second_mot = input()
mot_final = None

for i in range(min(longueur_premier_mot, longueur_second_mot)):
    lettre_1 = premier_mot[i]
    lettre_2 = second_mot[i]
    if ord(lettre_1) < ord(lettre_2):
        mot_final = premier_mot
        break
    elif ord(lettre_2) < ord(lettre_1):
        mot_final = second_mot
        break

if mot_final is None:
    mot_final = premier_mot if longueur_premier_mot < longueur_second_mot else second_mot

print(mot_final)
```

* Argh, un `break` ; ce n'est pas interdit, mais on peut l'√©viter avec une fonction, et obtenir un *doctest* au passage.


### Proposition 5

```python
def ordre(mot1, mot2):
    """ Renvoie le premier mot selon l'ordre lexicographique.
    >>> ordre('prologin', 'prolo')
    'prolo'
    """ 
    if mot1 < mot2:
        return mot1
    else:
        return mot2

# Test
import doctest
doctest.testmod()

# Entr√©es
nb1 = int(input())
mot1 = input()
nb2 = int(input())
mot2= input()

if not (1< len(mot1) < 1000):
    raise ValueError("Trop de lettres au premier mot")
if not (1< len(mot2) < 1000):
    raise ValueError("Trop de lettres au deuxi√®me mot")

# Sortie
print(ordre(mot1, mot2))
```

* L'utilisation de `<` directement sur les cha√Ænes √©tait interdite ici... C'est tricher !


### Proposition 6

```python
liste_tryer = []
longueur_mots1 = int(input())
liste_tryer.append(input())
longueur_mots2 = int(input())
liste_tryer.append(input())
liste_tryer.sort()
print(liste_tryer[0])

""" 
interdit 
if premier_mots <= deuxieme_mots:
    print(premier_mots)
else:
    print(deuxieme_mots)
"""
```

* Utiliser `.sort()` c'est comme utiliser `<=` ; c'est interdit aussi ici üòâ


### Proposition 7

```python
"""
Cette algorithme renvoie la premi√®re chaine de caract√®re selon l'ordre lexicographique (ordre du dictionnaire).

Exemple d'entr√©e:  8 
                   prologin 
                   5 
                   prolo 
Exemple de sortie: prolo 

Exemple d'entr√©e:  4 
                   toto 
                   4 
                   titi 
Exemple de sortie: titi

"""

# tests 
import doctest 
doctest.testmod()

#Entr√©e 
nb1_chaine_cara = int(input()) 
mot_1 = input() 
nb2_chaine_cara = int(input()) 
mot_2 = input() 

#Algorithme 
Liste =[mot_1,mot_2]
Liste_tri√©e = sorted(Liste) 

#Sortie
print(Liste[0])
```


* L'utilisation de `sorted` √©tait interdite.


### Proposition 8

```python
# 0- Coeur du programme

def comparaison(longueur_1: int, cha√Æne_1: str, longueur_2: int, cha√Æne_2:str) -> str:
    """ Renvoie le premier mot entre cha√Æne_1 et cha√Æne_2 dans l'ordre lexicographique
    >>> comparaison(8, "prologin", 5, "prolo")
    'prolo'
    >>> comparaison(4, "toto", 4, "titi")
    'titi'
    """

    alphabet = "abcdefghijklmnopqrstuvwxyz"                     
    id_lettre = 0 
    while longueur_1 != id_lettre and longueur_2 != id_lettre:  # On continue tant que les cha√Ænes ont encore des lettres .
        if cha√Æne_1[id_lettre] != cha√Æne_2[id_lettre]:          # Si, les 2 lettres des 2 cha√Ænes sont diff√©rentes alors, 
            for lettre in alphabet:                             # On peut d√©terminer le premier avec l'ordre de l'alphabet.
                if cha√Æne_1[id_lettre] == lettre:              
                    return cha√Æne_1
                if cha√Æne_2[id_lettre] == lettre:
                    return cha√Æne_2
        id_lettre += 1
    if longueur_1 == id_lettre:                                 # Les 2 cha√Ænes n'ont pas la m√™me longueur
        return cha√Æne_1                                         # Donc,celui qui a arr√™t√© la boucle est le premier et a une longueur √©gale √† id_lettre
    else:
        return cha√Æne_2

# 1- Tests

import doctest
doctest.testmod()

# 2- Lecture des entr√©es

longueur_1 = int(input())
cha√Æne_1 = input()
longueur_2 = int(input())
cha√Æne_2 = input()

# 3- Appel de la fonction / Sortie

print(comparaison(longueur_1, cha√Æne_1, longueur_2, cha√Æne_2))
```

* Pas de triche ici, c'est bien.
* On pouvait faire plus simple.

### Proposition 9

```python
def premi√®re_cha√Æne(nb_caracteres_1 : int, cha√Æne_1 : str, nb_caracteres_2 : int, cha√Æne_2 : str,) -> str :
    """ Renvoie la premi√®re cha√Æne de caract√®re selon l'ordre lexicographique
    entre 'cha√Æne_1' et 'cha√Æne_2'.
    >>> nb_caracteres_1 = 8
    >>> cha√Æne_1 = prologin
    >>> nb_caracteres_2 = 5
    >>> cha√Æne_2 = prolo
    prolo
    """
    longueur_max = max(len(cha√Æne_1), len(cha√Æne_2))
    mot1, mot2 = list(cha√Æne_1), list(cha√Æne_2)
    sortie = ''
    for lettre in range (longueur_max) :
        if mot1[lettre] > mot2[lettre] :
            sortie.append(cha√Æne_2) 
            break
        if mot1[lettre] < mot2[lettre] :
            sortie.append(cha√Æne_1) 
            break
        if mot1[lettre] == ' ' :
            sortie.append(cha√Æne_1) 
            break
        if mot2[lettre] == ' ' :
            sortie.append(cha√Æne_2) 
            break
        return sortie

# tests
import doctest
doctest.testmod()

# Entr√©e
nb_caracteres_1 = int(input())
cha√Æne_1 = input()
nb_caracteres_2 = int(input())
cha√Æne_2 = input()

# Sortie
print(premi√®re_cha√Æne(nb_caracteres_1, cha√Æne_2, nb_caracteres_2, cha√Æne_2))
```

* Attention, `sortie` est de type `str` et ne poss√®de pas de m√©thode `.append`.
* Erreur si un mot est un pr√©fixe de l'autre. `pro` et `produit` donne 7 tours de boucle, qui ne sont pas arr√™t√©s, au quatri√®me tour, une erreur se produit pour lire le quatri√®me caract√®re de `pro` qui n'existe pas.

## Corrig√© du professeur

```python
"""
auteur : Franck CHAMBON
https://prologin.org/train/2003/qualification/cases_inaccessibles
"""

def plus_petite(cha√Æne_1: str, cha√Æne_2: str) -> str:
    """Renvoie la plus petite des deux cha√Ænes.
    En suivant l'ordre lexicographique,
    et sans utiliser la fonction de la biblioth√®que interne.

    >>> plus_petite("prologin", "prolo")
    'prolo'

    >>> plus_petite("toto", "titi")
    'titi'

    """
    taille_1 = len(cha√Æne_1)
    taille_2 = len(cha√Æne_2)
    taille_commune = min(taille_1, taille_2)
    for i in range(taille_commune):
        c_1 = cha√Æne_1[i]
        c_2 = cha√Æne_2[i]
        if c_1 < c_2:
            return cha√Æne_1
        if c_2 < c_1:
            return cha√Æne_2
    if taille_1 < taille_2:
        return cha√Æne_1
    if taille_2 < taille_1:
        return cha√Æne_2
    # ici on a 
    assert cha√Æne_1 == cha√Æne_2, f"Erreur curieuse"
    return cha√Æne_1

import doctest
doctest.testmod()

taille_1 = int(input())
cha√Æne_1 = input()
taille_2 = int(input())
cha√Æne_2 = input()

print(plus_petite(cha√Æne_1, cha√Æne_2))
```

* Traditionnellement `c` est souvent un identifiant pour un **c**aract√®re d'une cha√Æne.
* Utiliser `sort`, `sorted` ou `<` sur les cha√Ænes √©tait tricher, le sujet demandait de ne pas utiliser de fonction toute pr√™te de la biblioth√®que.

> Il ne faut pas chercher √† contourner un probl√®me pour progresser, voire il faut savoir en imaginer...